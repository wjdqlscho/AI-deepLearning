# -*- coding: utf-8 -*-
"""2026108_조정빈_컴퓨터비전_5_1주차

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NLENekRKZqteekQSigHQ9g1-crXDnhbF
"""

!pip install opencv-python-headless

import cv2
import numpy as np
from google.colab.patches import cv2_imshow
import time

print("OpenCV version :", cv2.__version__)
print("OpenCV version :", cv2.__version__)

!wget -O gray_image.jpg "https://blog.aspose.cloud/ko/imaging/grayscale-image-in-java/images/grayscale.jpg" -q

image_path = 'gray_image.jpg'
image = cv2.imread(image_path)

if image is None:
  print("이미지를 불러오지 못했습니다. 경로를 확인하세요.")
else:
  print("이미지 로드 성공!")
  cv2_imshow(image)

"""**컨볼루션과 크로스코릴레이션**

-> 컨볼루션은 커널을 180도 회전한 뒤 적용하고, 크로스코릴레이션은 커널을 뒤집지 않고 그대로 곱-합을 구함
"""

#에지 검출 : 결론은 미분값이 0인 지점을 의미한다. 필터 마스크를 더했을 때 0이 되어야 한다. --> 엣지를 찾아야하기 때문임

if image is not None:
  # 예시, 수직엣지 검출 커널
  gray_conv = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
  kernel_edge = np.array([[-1, -1, -1],
                          [-1, 8, -1],
                          [-1, -1, -1]], dtype = np.float32)
  # 크로스 코릴레이션(filter2D)
  corr_result = cv2.filter2D(gray_conv, -1, kernel_edge)

  # 컨볼루션, 커널 180도 회전 후 filter2D
  conv_kernel = np.flip(kernel_edge)
  conv_result = cv2.filter2D(gray_conv, -1, conv_kernel)

  print("Cross-correlation : ")
  cv2_imshow(corr_result)

  print("Convolution : ")
  cv2_imshow(conv_result)

"""# ***엣지 검출 필터***
```
1.   cv2.filter2D(src, ddepth, kernel) : 임의 커널 제공
2.   cv2.blur(src, ksize) : 평균 필터
3.   cv2.GausssianBlur(src, ksize, sigmaX): 가우시안 블러
4.   cv2.medianBlur(src, ksize) : 미디언 필터
5.   cv2.Sobel(src, dddepth, dx, dy, ksize) : Sobel 엣지 검출
```
"""

if image is not None:
  kernel_size = 3
  kernel = np.ones((kernel_size, kernel_size), np.float32) / (kernel_size**2)
  avg_custom = cv2.filter2D(image, -1, kernel)
  print("Custom Average filter (3x3) using filter2D : ")
  cv2_imshow(avg_custom)

from re import X
if image is not None:
  blur_ = cv2.blur(image, (5, 5))
  gauss_ = cv2.GaussianBlur(image, (5, 5), 0)
  median_ = cv2.medianBlur(image, 5)

  print("Average filter : ")
  cv2_imshow(blur_)
  print("Gaussian filter : ")
  cv2_imshow(gauss_)
  print("Median filter : ")
  cv2_imshow(median_)

"""# ***SOBEL 엣지 검출***"""

if image is not None:
  gray_sobel = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
  sobelx = cv2.Sobel(gray_sobel, cv2.CV_64F, 1, 0, ksize = 3)
  sobely = cv2.Sobel(gray_sobel, cv2.CV_64F, 0, 1, ksize = 3)
  sobelx = cv2.convertScaleAbs(sobelx)
  sobely = cv2.convertScaleAbs(sobely)
  sobel_combined = cv2.addWeighted(sobelx, 0.5, sobely, 0.5, 0)

  print("Sobel x : ")
  cv2_imshow(sobelx)
  print("Sobel y : ")
  cv2_imshow(sobely)
  print("Sobel combined : ")
  cv2_imshow(sobel_combined)

"""## ***모폴로지 연산(모폴리지 = 형태)***
이진, 이미지에서 노이즈 제거, 객체 크기 조정 등에 유용함



*   침식(erosion): 밝은 영역을 축소
*   팽창(dilation) : 밝은 영역을 확대
*   열기(opening) : 침식 후 팽창(작은 잡음 제거)
*   닫기(closing) : 팽창 후 침식(작은 구멍 메우기)



```
***OPEN가 CLOSED의 차이 --> open은 침식 후 팽창, close는 팽창 다음에 깎아내는 방식이다.***
```



"""

if image is not None:
  gray_morph = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
  ret, thresh = cv2.threshold(gray_morph, 128, 255, cv2.THRESH_BINARY)
  kernel = np.ones((5, 5), np.uint8)

  eroded = cv2.erode(thresh, kernel, iterations = 1)
  dilated = cv2.dilate(thresh, kernel, iterations = 1)
  opened = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, kernel)
  closed = cv2.morphologyEx(thresh, cv2.MORPH_CLOSE, kernel)

  print("Original : ")
  cv2_imshow(thresh)
  print("Erosion : 밝은 영역을 축소")
  cv2_imshow(eroded)
  print("Dilation : 밝은 영역을 확대")
  cv2_imshow(dilated)
  print("Opening : 침식 후 팽창(작은 잡음 제거)")
  cv2_imshow(opened)
  print("Closing : 팽창 후 침식(작은 구멍 메우기)")
  cv2_imshow(closed)

"""# **Bilateral Filter**
 - 엣지 근처에서 색상 차이가 크면 블러를 적게 적용해, 엣지 보존이 가능한 필터


# **Non-local Means**
 - 이미지 전역 범위에서 유사 패치(patch)를 찾아 평균화해 노이즈를 제거한다. 노이즈 제거 성능이 뛰어나지만, 계산비용이 큼
"""

if image is not None:
  bilateral = cv2.bilateralFilter(image, 9, 75, 75)
  print("Bilateral Filter : ")
  cv2_imshow(bilateral)

  denosied_res = cv2.fastNlMeansDenoisingColored(image, None, 10, 10, 7, 21)
  print("Non-local Means : ")
  cv2_imshow(denosied_res)

"""# ***샤프닝***"""

if image is not None:
  blur_for_unsharp = cv2.GaussianBlur(image, (9, 9), 10)
  alpha = 1.5
  unsharp = cv2.addWeighted(image, 1 + alpha, blur_for_unsharp, -alpha, 0)
  print("Unsharp : ")
  cv2_imshow(unsharp)

"""# **Canny edge 가우시안블러 + 1차미분**

# **Laplacian**
"""

if image is not None:
  gray_edges = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

  for (t1, t2) in [(50, 150), (100, 200), (150, 250)]:
    canny = cv2.Canny(gray_edges, t1, t2)
    print(f"Canny (threshold1 = {t1}, threshold2 = {t2})")
    cv2_imshow(canny)

  for ksize_ in [1, 3, 5]:
    laplacian = cv2.Laplacian(gray_edges, cv2.CV_64F, ksize = ksize_)
    laplacian = cv2.convertScaleAbs(laplacian)
    print(f"Laplacian (ksize = {ksize_})")
    cv2_imshow(laplacian)

"""# **Gabor 필터**"""

def apply_gabor_filter(img, ksize, sigma, theta, lambd, gamma, psi = 0):
  gabor_kernel = cv2.getGaborKernel((ksize, ksize), sigma, theta, lambd, gamma, psi)
  gray_img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
  filtered_img = cv2.filter2D(gray_img, cv2.CV_8UC3, gabor_kernel)
  return filtered_img

if image is not None:
  for theta_ in [0, np.pi/4, np.pi/2, 3*np.pi/4]:
    gabor_res = apply_gabor_filter(image, 31, 4.0, theta_, 10.0, 0.5)
    print(f"Gabor filter (theta = {theta_})")
    cv2_imshow(gabor_res)