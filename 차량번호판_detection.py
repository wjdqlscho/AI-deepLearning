# -*- coding: utf-8 -*-
"""차량번호판_detection

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/101Zku_N6XC_Lkg2kTfncnqLFySOkT28O
"""

# Commented out IPython magic to ensure Python compatibility.
import torch
import torch.nn as nn
import torch.nn.functional as F
import torch.optim as optim
import torchvision
import torchvision.transforms as transforms
import numpy as np
import matplotlib.pyplot as plt

device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
print("사용가능한 디바이스 : ", device)
# %matplotlib inline

import cv2

img = cv2.imread('/content/차량.jpeg')

height, width, channel = img.shape

plt.figure(figsize=(12, 10))
plt.imshow(img,cmap='gray')
print(height, width, channel)

gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
plt.figure(figsize=(12,10))
plt.imshow(gray, cmap='gray')
hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)
gray = hsv[:, :, 2]
plt.figure(figsize=(12,10))
plt.imshow(gray, cmap='gray')

img_blurred = cv2.GaussianBlur(gray, ksize=(5, 5), sigmaX=0)

img_blur_thresh = cv2.adaptiveThreshold(
    img_blurred,
    maxValue=255.0,
    adaptiveMethod=cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
    thresholdType=cv2.THRESH_BINARY_INV,
    blockSize=19,
    C=9
)

img_thresh = cv2.adaptiveThreshold(
    gray,
    maxValue=255.0,
    adaptiveMethod=cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
    thresholdType=cv2.THRESH_BINARY_INV,
    blockSize=19,
    C=9
)

plt.figure(figsize=(20,20))
plt.subplot(1,2,1)
plt.title('Threshold only')
plt.imshow(img_thresh, cmap='gray')
plt.subplot(1,2,2)
plt.title('Blur and Threshold')
plt.imshow(img_blur_thresh, cmap='gray')

contours, _ = cv2.findContours(
    img_blur_thresh,
    mode=cv2.RETR_LIST,
    method=cv2.CHAIN_APPROX_SIMPLE
)

temp_result = np.zeros((height, width, channel), dtype=np.uint8)

cv2.drawContours(temp_result, contours=contours, contourIdx=-1, color=(255,255,255))

plt.figure(figsize=(12, 10))
plt.imshow(temp_result)

temp_result = np.zeros((height, width, channel), dtype=np.uint8)

contours_dict = []

for contour in contours:
    x, y, w, h = cv2.boundingRect(contour)
    cv2.rectangle(temp_result, pt1=(x,y), pt2=(x+w, y+h), color=(255,255,255), thickness=2)

    contours_dict.append({
        'contour': contour,
        'x': x,
        'y': y,
        'w': w,
        'h': h,
        'cx': x + (w / 2),
        'cy': y + (h / 2)
    })

plt.figure(figsize=(12,10))
plt.imshow(temp_result, cmap='gray')

MIN_AREA = 50
MIN_WIDTH, MIN_HEIGHT=2, 8
MIN_RATIO, MAX_RATIO = 0.25, 1.0

possible_contours = []

cnt = 0
for d in contours_dict:
    area = d['w'] * d['h']
    ratio = d['w'] / d['h']

    if area > MIN_AREA \
    and d['w'] > MIN_WIDTH and d['h'] > MIN_HEIGHT \
    and MIN_RATIO < ratio < MAX_RATIO:
        d['idx'] = cnt
        cnt += 1
        possible_contours.append(d)

temp_result = np.zeros((height, width, channel), dtype = np.uint8)

for d in possible_contours:
    cv2.rectangle(temp_result, pt1=(d['x'], d['y']), pt2=(d['x']+d['w'], d['y']+d['h']), color=(255, 255, 255), thickness=2)

plt.figure(figsize=(12, 10))
plt.imshow(temp_result, cmap='gray')

import cv2
import numpy as np

MIN_N_MATCHED = 4

def find_plate_groups(contours):
    groups = []
    for i, d1 in enumerate(contours):
        matched = []
        for j, d2 in enumerate(contours):
            if i == j: continue
            dx = abs(d1['cx'] - d2['cx'])
            dy = abs(d1['cy'] - d2['cy'])
            dist = np.hypot(dx, dy)
            angle = np.degrees(np.arctan2(dy, dx)) if dx != 0 else 90
            aratio = abs(d1['w'] * d1['h'] - d2['w'] * d2['h']) / max(d1['w'] * d1['h'], d2['w'] * d2['h'])
            if dist < d1['w'] * 5 and angle < 12 and aratio < 0.5:
                matched.append(d2)
        matched.append(d1)
        if len(matched) >= MIN_N_MATCHED:
            groups.append(matched)
    return groups

for d in possible_contours:
    d['cx'] = d['x'] + d['w'] // 2
    d['cy'] = d['y'] + d['h'] // 2

plate_groups = find_plate_groups(possible_contours)

output = np.zeros((height, width, channel), dtype=np.uint8)
for group in plate_groups:
    for d in group:
        cv2.rectangle(output, (d['x'], d['y']), (d['x']+d['w'], d['y']+d['h']), (255, 255, 255), 2)

import matplotlib.pyplot as plt
plt.figure(figsize=(12, 10))
plt.imshow(output, cmap='gray')
plt.axis('off')
plt.show()

output_img = img.copy()

for group in plate_groups:
    x_list = [d['x'] for d in group]
    y_list = [d['y'] for d in group]
    w_list = [d['x'] + d['w'] for d in group]
    h_list = [d['y'] + d['h'] for d in group]

    x_min, y_min = min(x_list), min(y_list)
    x_max, y_max = max(w_list), max(h_list)

    cv2.rectangle(output_img, (x_min, y_min), (x_max, y_max), (0, 0, 255), 2)  # 빨간색

plt.figure(figsize=(12, 8))
plt.imshow(cv2.cvtColor(output_img, cv2.COLOR_BGR2RGB))
plt.title("Detection")
plt.axis("off")
plt.show()